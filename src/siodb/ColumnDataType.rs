// This file is generated by rust-protobuf 2.12.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ColumnDataType.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_12_0;

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ColumnDataType {
    COLUMN_DATA_TYPE_BOOL = 0,
    COLUMN_DATA_TYPE_INT8 = 1,
    COLUMN_DATA_TYPE_UINT8 = 2,
    COLUMN_DATA_TYPE_INT16 = 3,
    COLUMN_DATA_TYPE_UINT16 = 4,
    COLUMN_DATA_TYPE_INT32 = 5,
    COLUMN_DATA_TYPE_UINT32 = 6,
    COLUMN_DATA_TYPE_INT64 = 7,
    COLUMN_DATA_TYPE_UINT64 = 8,
    COLUMN_DATA_TYPE_FLOAT = 9,
    COLUMN_DATA_TYPE_DOUBLE = 10,
    COLUMN_DATA_TYPE_TEXT = 11,
    COLUMN_DATA_TYPE_NTEXT = 12,
    COLUMN_DATA_TYPE_BINARY = 13,
    COLUMN_DATA_TYPE_DATE = 14,
    COLUMN_DATA_TYPE_TIME = 15,
    COLUMN_DATA_TYPE_TIME_WITH_TZ = 16,
    COLUMN_DATA_TYPE_TIMESTAMP = 17,
    COLUMN_DATA_TYPE_TIMESTAMP_WITH_TZ = 18,
    COLUMN_DATA_TYPE_DATE_INTERVAL = 19,
    COLUMN_DATA_TYPE_TIME_INTERVAL = 20,
    COLUMN_DATA_TYPE_STRUCT = 21,
    COLUMN_DATA_TYPE_XML = 22,
    COLUMN_DATA_TYPE_JSON = 23,
    COLUMN_DATA_TYPE_UUID = 24,
    COLUMN_DATA_TYPE_MAX = 25,
    COLUMN_DATA_TYPE_UNKNOWN = 127,
}

impl ::protobuf::ProtobufEnum for ColumnDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ColumnDataType> {
        match value {
            0 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_BOOL),
            1 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_INT8),
            2 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_UINT8),
            3 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_INT16),
            4 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_UINT16),
            5 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_INT32),
            6 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_UINT32),
            7 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_INT64),
            8 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_UINT64),
            9 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_FLOAT),
            10 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_DOUBLE),
            11 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_TEXT),
            12 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_NTEXT),
            13 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_BINARY),
            14 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_DATE),
            15 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_TIME),
            16 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_TIME_WITH_TZ),
            17 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_TIMESTAMP),
            18 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_TIMESTAMP_WITH_TZ),
            19 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_DATE_INTERVAL),
            20 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_TIME_INTERVAL),
            21 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_STRUCT),
            22 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_XML),
            23 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_JSON),
            24 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_UUID),
            25 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_MAX),
            127 => ::std::option::Option::Some(ColumnDataType::COLUMN_DATA_TYPE_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ColumnDataType] = &[
            ColumnDataType::COLUMN_DATA_TYPE_BOOL,
            ColumnDataType::COLUMN_DATA_TYPE_INT8,
            ColumnDataType::COLUMN_DATA_TYPE_UINT8,
            ColumnDataType::COLUMN_DATA_TYPE_INT16,
            ColumnDataType::COLUMN_DATA_TYPE_UINT16,
            ColumnDataType::COLUMN_DATA_TYPE_INT32,
            ColumnDataType::COLUMN_DATA_TYPE_UINT32,
            ColumnDataType::COLUMN_DATA_TYPE_INT64,
            ColumnDataType::COLUMN_DATA_TYPE_UINT64,
            ColumnDataType::COLUMN_DATA_TYPE_FLOAT,
            ColumnDataType::COLUMN_DATA_TYPE_DOUBLE,
            ColumnDataType::COLUMN_DATA_TYPE_TEXT,
            ColumnDataType::COLUMN_DATA_TYPE_NTEXT,
            ColumnDataType::COLUMN_DATA_TYPE_BINARY,
            ColumnDataType::COLUMN_DATA_TYPE_DATE,
            ColumnDataType::COLUMN_DATA_TYPE_TIME,
            ColumnDataType::COLUMN_DATA_TYPE_TIME_WITH_TZ,
            ColumnDataType::COLUMN_DATA_TYPE_TIMESTAMP,
            ColumnDataType::COLUMN_DATA_TYPE_TIMESTAMP_WITH_TZ,
            ColumnDataType::COLUMN_DATA_TYPE_DATE_INTERVAL,
            ColumnDataType::COLUMN_DATA_TYPE_TIME_INTERVAL,
            ColumnDataType::COLUMN_DATA_TYPE_STRUCT,
            ColumnDataType::COLUMN_DATA_TYPE_XML,
            ColumnDataType::COLUMN_DATA_TYPE_JSON,
            ColumnDataType::COLUMN_DATA_TYPE_UUID,
            ColumnDataType::COLUMN_DATA_TYPE_MAX,
            ColumnDataType::COLUMN_DATA_TYPE_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<ColumnDataType>("ColumnDataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ColumnDataType {
}

impl ::std::default::Default for ColumnDataType {
    fn default() -> Self {
        ColumnDataType::COLUMN_DATA_TYPE_BOOL
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14ColumnDataType.proto\x12\x05siodb*\xa8\x06\n\x0eColumnDataType\x12\
    \x19\n\x15COLUMN_DATA_TYPE_BOOL\x10\0\x12\x19\n\x15COLUMN_DATA_TYPE_INT8\
    \x10\x01\x12\x1a\n\x16COLUMN_DATA_TYPE_UINT8\x10\x02\x12\x1a\n\x16COLUMN\
    _DATA_TYPE_INT16\x10\x03\x12\x1b\n\x17COLUMN_DATA_TYPE_UINT16\x10\x04\
    \x12\x1a\n\x16COLUMN_DATA_TYPE_INT32\x10\x05\x12\x1b\n\x17COLUMN_DATA_TY\
    PE_UINT32\x10\x06\x12\x1a\n\x16COLUMN_DATA_TYPE_INT64\x10\x07\x12\x1b\n\
    \x17COLUMN_DATA_TYPE_UINT64\x10\x08\x12\x1a\n\x16COLUMN_DATA_TYPE_FLOAT\
    \x10\t\x12\x1b\n\x17COLUMN_DATA_TYPE_DOUBLE\x10\n\x12\x19\n\x15COLUMN_DA\
    TA_TYPE_TEXT\x10\x0b\x12\x1a\n\x16COLUMN_DATA_TYPE_NTEXT\x10\x0c\x12\x1b\
    \n\x17COLUMN_DATA_TYPE_BINARY\x10\r\x12\x19\n\x15COLUMN_DATA_TYPE_DATE\
    \x10\x0e\x12\x19\n\x15COLUMN_DATA_TYPE_TIME\x10\x0f\x12!\n\x1dCOLUMN_DAT\
    A_TYPE_TIME_WITH_TZ\x10\x10\x12\x1e\n\x1aCOLUMN_DATA_TYPE_TIMESTAMP\x10\
    \x11\x12&\n\"COLUMN_DATA_TYPE_TIMESTAMP_WITH_TZ\x10\x12\x12\"\n\x1eCOLUM\
    N_DATA_TYPE_DATE_INTERVAL\x10\x13\x12\"\n\x1eCOLUMN_DATA_TYPE_TIME_INTER\
    VAL\x10\x14\x12\x1b\n\x17COLUMN_DATA_TYPE_STRUCT\x10\x15\x12\x18\n\x14CO\
    LUMN_DATA_TYPE_XML\x10\x16\x12\x19\n\x15COLUMN_DATA_TYPE_JSON\x10\x17\
    \x12\x19\n\x15COLUMN_DATA_TYPE_UUID\x10\x18\x12\x18\n\x14COLUMN_DATA_TYP\
    E_MAX\x10\x19\x12\x1c\n\x18COLUMN_DATA_TYPE_UNKNOWN\x10\x7fB\x02H\x01J\
    \xa9\x15\n\x06\x12\x04\x04\0+\x01\n\x9f\x01\n\x01\x0c\x12\x03\x04\0\x122\
    \x94\x01\x20Copyright\x20(C)\x202019-2020\x20Siodb\x20GmbH.\x20All\x20ri\
    ghts\x20reserved.\n\x20Use\x20of\x20this\x20source\x20code\x20is\x20gove\
    rned\x20by\x20a\x20license\x20that\x20can\x20be\x20found\n\x20in\x20the\
    \x20LICENSE\x20file.\n\n\x08\n\x01\x02\x12\x03\x06\0\x0e\n\x08\n\x01\x08\
    \x12\x03\x08\0\x1a\n\t\n\x02\x08\t\x12\x03\x08\0\x1a\n!\n\x02\x05\0\x12\
    \x04\x0b\0+\x01\x1a\x15*\x20Column\x20data\x20types.\x20\n\n\n\x03\x05\0\
    \x01\x12\x03\x0b\x05\x13\n\x1d\n\x04\x05\0\x02\0\x12\x03\x0c\x04\x1e\"\
    \x10/\x20SQL99\x20BOOLEAN\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x0c\x04\
    \x19\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x0c\x1c\x1d\n3\n\x04\x05\0\x02\
    \x01\x12\x03\r\x04\x1e\"&/\x20SQL99\x20NUMERIC:\x208-bit\x20signed\x20in\
    teger\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\r\x04\x19\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03\r\x1c\x1d\n5\n\x04\x05\0\x02\x02\x12\x03\x0e\x04\
    \x1f\"(/\x20SQL99\x20NUMERIC:\x208-bit\x20unsigned\x20integer\n\n\x0c\n\
    \x05\x05\0\x02\x02\x01\x12\x03\x0e\x04\x1a\n\x0c\n\x05\x05\0\x02\x02\x02\
    \x12\x03\x0e\x1d\x1e\n4\n\x04\x05\0\x02\x03\x12\x03\x0f\x04\x1f\"'/\x20S\
    QL99\x20NUMERIC:\x2016-bit\x20signed\x20integer\n\n\x0c\n\x05\x05\0\x02\
    \x03\x01\x12\x03\x0f\x04\x1a\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x0f\
    \x1d\x1e\n6\n\x04\x05\0\x02\x04\x12\x03\x10\x04\x20\")/\x20SQL99\x20NUME\
    RIC:\x2016-bit\x20unsigned\x20integer\n\n\x0c\n\x05\x05\0\x02\x04\x01\
    \x12\x03\x10\x04\x1b\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x10\x1e\x1f\n\
    4\n\x04\x05\0\x02\x05\x12\x03\x11\x04\x1f\"'/\x20SQL99\x20NUMERIC:\x2032\
    -bit\x20signed\x20integer\n\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x11\
    \x04\x1a\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x11\x1d\x1e\n6\n\x04\x05\
    \0\x02\x06\x12\x03\x12\x04\x20\")/\x20SQL99\x20NUMERIC:\x2032-bit\x20uns\
    igned\x20integer\n\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x12\x04\x1b\n\
    \x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x12\x1e\x1f\n4\n\x04\x05\0\x02\x07\
    \x12\x03\x13\x04\x1f\"'/\x20SQL99\x20NUMERIC:\x2064-bit\x20signed\x20int\
    eger\n\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x13\x04\x1a\n\x0c\n\x05\x05\
    \0\x02\x07\x02\x12\x03\x13\x1d\x1e\n6\n\x04\x05\0\x02\x08\x12\x03\x14\
    \x04\x20\")/\x20SQL99\x20NUMERIC:\x2064-bit\x20unsigned\x20integer\n\n\
    \x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x14\x04\x1b\n\x0c\n\x05\x05\0\x02\
    \x08\x02\x12\x03\x14\x1e\x1f\nB\n\x04\x05\0\x02\t\x12\x03\x15\x04\x1f\"5\
    /\x20SQL99\x20FLOAT:\x2032-bit\x20IEEE-754\x20floating-point\x20number\n\
    \n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x15\x04\x1a\n\x0c\n\x05\x05\0\x02\t\
    \x02\x12\x03\x15\x1d\x1e\n,\n\x04\x05\0\x02\n\x12\x03\x16\x04!\"\x1f/\
    \x20SQL99\x20REAL/DOUBLE\x20PRECISION:\n\n\x0c\n\x05\x05\0\x02\n\x01\x12\
    \x03\x16\x04\x1b\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x16\x1e\x20\nu\n\
    \x04\x05\0\x02\x0b\x12\x03\x18\x04\x1f\x1a(/\x2064-bit\x20IEEE-754\x20fl\
    oating-point\x20number\n\">/\x20SQL99\x20CHAR,\x20VARCHAR,\x20CLOB:\x20T\
    extual\x20data\x20with\x20UTF-8\x20encoding\n\n\x0c\n\x05\x05\0\x02\x0b\
    \x01\x12\x03\x18\x04\x19\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x18\x1c\
    \x1e\nA\n\x04\x05\0\x02\x0c\x12\x03\x19\x04\x20\"4/\x20[NOT\x20SUPPORTED\
    \x20YET]\x20SQL99\x20NCHAR,\x20NVARCHAR,\x20NCLOB:\n\n\x0c\n\x05\x05\0\
    \x02\x0c\x01\x12\x03\x19\x04\x1a\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\
    \x19\x1d\x1f\ng\n\x04\x05\0\x02\r\x12\x03\x1b\x04!\x1a*/\x20Textual\x20d\
    ata\x20with\x20altertnative\x20encoding\n\"./\x20SQL99\x20BLOB:\x20Binar\
    y\x20data\x20of\x20unlimited\x20length\n\n\x0c\n\x05\x05\0\x02\r\x01\x12\
    \x03\x1b\x04\x1b\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x1b\x1e\x20\n9\n\
    \x04\x05\0\x02\x0e\x12\x03\x1c\x04\x1f\",/\x20[NOT\x20SUPPORTED\x20YET]\
    \x20SQL99\x20DATE:\x20Date\x20only\n\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\
    \x03\x1c\x04\x19\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x1c\x1c\x1e\n9\n\
    \x04\x05\0\x02\x0f\x12\x03\x1d\x04\x1f\",/\x20[NOT\x20SUPPORTED\x20YET]\
    \x20SQL99\x20TIME:\x20Time\x20only\n\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\
    \x03\x1d\x04\x19\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03\x1d\x1c\x1e\n>\n\
    \x04\x05\0\x02\x10\x12\x03\x1e\x04'\"1/\x20[NOT\x20SUPPORTED\x20YET]\x20\
    SQL99\x20TIME\x20WITH\x20TIME\x20ZONE:\n\n\x0c\n\x05\x05\0\x02\x10\x01\
    \x12\x03\x1e\x04!\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x1e$&\nZ\n\x04\
    \x05\0\x02\x11\x12\x03\x20\x04$\x1a\x16/\x20Time\x20with\x20time\x20zone\
    \n\"5/\x20[NOT\x20SUPPORTED\x20YET]\x20SQL99\x20TIMESTAMP:\x20Data\x20an\
    d\x20time\n\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x20\x04\x1e\n\x0c\n\
    \x05\x05\0\x02\x11\x02\x12\x03\x20!#\nC\n\x04\x05\0\x02\x12\x12\x03!\x04\
    ,\"6/\x20[NOT\x20SUPPORTED\x20YET]\x20SQL99\x20TIMESTAMP\x20WITH\x20TIME\
    \x20ZONE:\n\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03!\x04&\n\x0c\n\x05\x05\
    \0\x02\x12\x02\x12\x03!)+\nh\n\x04\x05\0\x02\x13\x12\x03#\x04(\x1a\x1f/\
    \x20Date\x20and\x20time\x20with\x20time\x20zone\n\":/\x20[NOT\x20SUPPORT\
    ED\x20YET]\x20SQL99\x20INTERVAL\x20of\x20years/months/days\n\n\x0c\n\x05\
    \x05\0\x02\x13\x01\x12\x03#\x04\"\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03#\
    %'\n=\n\x04\x05\0\x02\x14\x12\x03$\x04(\"0/\x20[NOT\x20SUPPORTED\x20YET]\
    \x20SQL99\x20INTERVAL\x20hours/days\n\n\x0c\n\x05\x05\0\x02\x14\x01\x12\
    \x03$\x04\"\n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03$%'\n>\n\x04\x05\0\x02\
    \x15\x12\x03%\x04!\"1/\x20[NOT\x20SUPPORTED\x20YET]\x20SQL99\x20Structur\
    ed\x20data\x20type\n\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03%\x04\x1b\n\
    \x0c\n\x05\x05\0\x02\x15\x02\x12\x03%\x1e\x20\n-\n\x04\x05\0\x02\x16\x12\
    \x03&\x04\x1e\"\x20/\x20[NOT\x20SUPPORTED\x20YET]\x20SQL99\x20XML\n\n\
    \x0c\n\x05\x05\0\x02\x16\x01\x12\x03&\x04\x18\n\x0c\n\x05\x05\0\x02\x16\
    \x02\x12\x03&\x1b\x1d\n>\n\x04\x05\0\x02\x17\x12\x03'\x04\x1f\"1/\x20[NO\
    T\x20SUPPORTED\x20YET]\x20Additional\x20data\x20type:\x20JSON\n\n\x0c\n\
    \x05\x05\0\x02\x17\x01\x12\x03'\x04\x19\n\x0c\n\x05\x05\0\x02\x17\x02\
    \x12\x03'\x1c\x1e\nI\n\x04\x05\0\x02\x18\x12\x03(\x04\x1f\"</\x20[NOT\
    \x20SUPPORTED\x20YET]\x20Additional\x20data\x20type:\x20UUID\x20(128\x20\
    bits)\n\n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03(\x04\x19\n\x0c\n\x05\x05\0\
    \x02\x18\x02\x12\x03(\x1c\x1e\n/\n\x04\x05\0\x02\x19\x12\x03)\x04\x1e\"\
    \"/\x20Upper\x20bound\x20of\x20data\x20type\x20number\n\n\x0c\n\x05\x05\
    \0\x02\x19\x01\x12\x03)\x04\x18\n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03)\
    \x1b\x1d\n&\n\x04\x05\0\x02\x1a\x12\x03*\x04#\"\x19/\x20Data\x20type\x20\
    is\x20not\x20known\n\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03*\x04\x1c\n\
    \x0c\n\x05\x05\0\x02\x1a\x02\x12\x03*\x1f\"b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
